#pragma once
/**
 * Variant-mode header generated by the GDExtension binding generator.
 *
 * - Uses mapped (Variant-friendly) signatures only.
 * - Never exposes raw void* in the public API; intptr_t/uint64_t are used instead.
 * - Wrapper-only mode: no ownership API for the native impl pointer.
 *
 * Wrapper: {{ cls.wrapper_name }}
 * Native : {{ cls.qualified_name }}
 */

#include <godot_cpp/classes/ref_counted.hpp>
#include <godot_cpp/core/class_db.hpp>
{# Determine if we need <cstdint> by scanning all mapped types #}
{% set ns = namespace(needs_stdint=false) %}
{% macro needs_stdint_from_type(t) -%}
    {%- set _t = (t or "") -%}
    {%- if "intptr_t" in _t or "uint64_t" in _t -%}
        {%- set ns.needs_stdint = true -%}
    {%- endif -%}
{%- endmacro %}
{% macro ty(t) -%}
    {# Replace any accidental void* spellings with intptr_t defensively #}
    {{ (t or "") | replace('void *', 'intptr_t') | replace('void*', 'intptr_t') }}
{%- endmacro %}

{# Scan constructors #}
{% if variant and variant.constructors %}
  {% for m in variant.constructors %}
    {% for p in m.params %}
      {{ needs_stdint_from_type(p.type) }}
    {% endfor %}
    {{ needs_stdint_from_type(m.return_type or "bool") }}
  {% endfor %}
{% endif %}
{# Scan instance methods #}
{% if variant and variant.instance_methods %}
  {% for m in variant.instance_methods %}
    {% for p in m.params %}
      {{ needs_stdint_from_type(p.type) }}
    {% endfor %}
    {{ needs_stdint_from_type(m.return_type) }}
  {% endfor %}
{% endif %}
{# Scan static methods #}
{% if variant and variant.static_methods %}
  {% for m in variant.static_methods %}
    {% for p in m.params %}
      {{ needs_stdint_from_type(p.type) }}
    {% endfor %}
    {{ needs_stdint_from_type(m.return_type) }}
  {% endfor %}
{% endif %}

{% if ns.needs_stdint %}
#include <cstdint>
{% endif %}

/* Include the native library header that defines {{ cls.qualified_name }}. */
#include <{{ cls.header }}>

namespace godot {

class {{ cls.wrapper_name }} : public RefCounted {
    GDCLASS({{ cls.wrapper_name }}, RefCounted)

  private:
    /* Wrapper-only mode: non-owning pointer to native impl (may be null). */
    {{ cls.absolute_qualified_name }}* impl = nullptr;

  protected:
    static void _bind_methods();

  public:
    {{ cls.wrapper_name }}();
    ~{{ cls.wrapper_name }}();

    // Construct the underlying native object using mapped constructors (optional)
{% if variant and variant.constructors %}
  {% for m in variant.constructors -%}
    {# Each constructor wrapper returns bool to indicate success #}
    bool construct{% if m.suffix %}{{ m.suffix }}{% endif %}(
      {%- for p in m.params -%}
        {{ ty(p.type) }} {{ (p.name or ('arg' ~ loop.index)) | sanitize }}{% if not loop.last %}, {% endif %}
      {%- endfor -%});
  {% endfor %}
{% endif %}

    // Variant-friendly instance methods
{% if variant and variant.instance_methods %}
  {% for m in variant.instance_methods -%}
    {{ ty(m.return_type) }} {{ (m.exposed_name or m.name) | sanitize }}(
      {%- for p in m.params -%}
        {{ ty(p.type) }} {{ (p.name or ('arg' ~ loop.index)) | sanitize }}{% if not loop.last %}, {% endif %}
      {%- endfor -%}
    ){% if m.is_const %} const{% endif %};
  {% endfor %}
{% endif %}

    // Variant-friendly static methods
{% if variant and variant.static_methods %}
  {% for m in variant.static_methods -%}
    static {{ ty(m.return_type) }} {{ (m.exposed_name or m.name) | sanitize }}(
      {%- for p in m.params -%}
        {{ ty(p.type) }} {{ (p.name or ('arg' ~ loop.index)) | sanitize }}{% if not loop.last %}, {% endif %}
      {%- endfor -%}
    );
  {% endfor %}
{% endif %}
};

} // namespace godot
