/**
 * This file is generated by the GDExtension binding generator.
 *
 * It implements the Godot wrapper for the external C++ type:
 *   Native : {{ cls.qualified_name }}
 *   Wrapper: {{ cls.wrapper_name }}
 *
 * The generator binds discovered methods automatically. Adjust ownership semantics as needed.
 */

#include "{{ cls.wrapper_name }}.h"

using namespace godot;

void {{ cls.wrapper_name }}::_bind_methods() {
    // Helper methods
    ClassDB::bind_method(D_METHOD("is_valid"), &{{ cls.wrapper_name }}::is_valid);
    ClassDB::bind_method(D_METHOD("reset"), &{{ cls.wrapper_name }}::reset);
    ClassDB::bind_method(D_METHOD("set_owns_impl", "own"), &{{ cls.wrapper_name }}::set_owns_impl);
    ClassDB::bind_method(D_METHOD("get_owns_impl"), &{{ cls.wrapper_name }}::get_owns_impl);

    // Constructor wrappers exposed as construct, construct_1, ...
    {% for m in cls.constructors %}
    {% set ctor_suffix = "_" ~ m.overload_index if m.overload_index is not none and m.overload_index > 0 else "" %}
    ClassDB::bind_method(
        D_METHOD("construct{{ ctor_suffix }}"{% for a in m.d_method_args %}, "{{ a }}"{% endfor %}),
        &{{ cls.wrapper_name }}::construct{{ ctor_suffix }}
    );
    {% endfor %}

    // Instance methods
    {% for m in cls.instance_methods %}
    ClassDB::bind_method(D_METHOD("{{ m.exposed_name }}"{% for a in m.d_method_args %}, "{{ a }}"{% endfor %}), &{{ cls.wrapper_name }}::{{ m.exposed_name }});
    {% endfor %}

    // Static methods
    {% for m in cls.static_methods %}
    ClassDB::bind_static_method({{ cls.wrapper_name }}::get_class_static(), D_METHOD("{{ m.exposed_name }}"{% for a in m.d_method_args %}, "{{ a }}"{% endfor %}), &{{ cls.wrapper_name }}::{{ m.exposed_name }});
    {% endfor %}
}

bool {{ cls.wrapper_name }}::is_valid() const {
    return impl != nullptr;
}

void {{ cls.wrapper_name }}::reset() {
    if (impl && owns_impl) {
        delete impl;
    }
    impl = nullptr;
}

void {{ cls.wrapper_name }}::set_impl({{ cls.absolute_qualified_name }}* p, bool p_take_ownership) {
    if (impl && owns_impl) {
        delete impl;
    }
    impl = p;
    owns_impl = p_take_ownership;
}

{{ cls.absolute_qualified_name }}* {{ cls.wrapper_name }}::get_impl() const {
    return impl;
}

void {{ cls.wrapper_name }}::set_owns_impl(bool p_own) {
    owns_impl = p_own;
}

bool {{ cls.wrapper_name }}::get_owns_impl() const {
    return owns_impl;
}

{% for m in cls.constructors -%}
// {{ m.cpp_signature }}
bool {{ cls.wrapper_name }}::construct{% if m.overload_index is not none and m.overload_index > 0 %}_{{ m.overload_index }}{% endif %}({% for p in m.parameters -%}{{ p.cpp_type.spelling }} {{ (p.name or ('arg' ~ loop.index)) | sanitize }}{% if not loop.last %}, {% endif %}{%- endfor -%}) {
    if (impl && owns_impl) {
        delete impl;
    }
    impl = new {{ cls.absolute_qualified_name }}({% for p in m.parameters -%}{{ (p.name or ('arg' ~ loop.index)) | sanitize }}{% if not loop.last %}, {% endif %}{%- endfor -%});
    return impl != nullptr;
}
{% endfor %}

{{ cls.wrapper_name }}::{{ cls.wrapper_name }}() {
    // Do not auto-construct; use construct(...) wrappers to initialize impl.
    impl = nullptr;
    owns_impl = true;
}

{{ cls.wrapper_name }}::~{{ cls.wrapper_name }}() {
    if (impl && owns_impl) {
        delete impl;
    }
    impl = nullptr;
}

{% for m in cls.instance_methods -%}
// {{ m.cpp_signature }}
{{ m.return_type.spelling }} {{ cls.wrapper_name }}::{{ m.exposed_name }}({% for p in m.parameters -%}{{ p.cpp_type.spelling }} {{ (p.name or ('arg' ~ loop.index)) | sanitize }}{% if not loop.last %}, {% endif %}{%- endfor -%}){% if m.is_const %} const{% endif %} {
    {% if m.return_type.spelling != "void" -%}
    return impl ? impl->{{ m.name }}({% for p in m.parameters -%}{{ (p.name or ('arg' ~ loop.index)) | sanitize }}{% if not loop.last %}, {% endif %}{%- endfor -%}) : {{ 'nullptr' if '*' in m.return_type.spelling else ('false' if m.return_type.spelling == 'bool' else '{}') }};
    {%- else -%}
    if (impl) {
        impl->{{ m.name }}({% for p in m.parameters -%}{{ (p.name or ('arg' ~ loop.index)) | sanitize }}{% if not loop.last %}, {% endif %}{%- endfor -%});
    }
    {%- endif %}
}
{% endfor %}

{% for m in cls.static_methods -%}
// static {{ m.cpp_signature }}
{{ m.return_type.spelling }} {{ cls.wrapper_name }}::{{ m.exposed_name }}({% for p in m.parameters -%}{{ p.cpp_type.spelling }} {{ (p.name or ('arg' ~ loop.index)) | sanitize }}{% if not loop.last %}, {% endif %}{%- endfor -%}) {
    {% if m.return_type.spelling != "void" -%}
    return {{ cls.absolute_qualified_name }}::{{ m.name }}({% for p in m.parameters -%}{{ (p.name or ('arg' ~ loop.index)) | sanitize }}{% if not loop.last %}, {% endif %}{%- endfor -%});
    {%- else -%}
    {{ cls.absolute_qualified_name }}::{{ m.name }}({% for p in m.parameters -%}{{ (p.name or ('arg' ~ loop.index)) | sanitize }}{% if not loop.last %}, {% endif %}{%- endfor -%});
    {%- endif %}
}
{% endfor %}
