#pragma once
/**
 * This file is generated by the GDExtension binding generator.
 *
 * It declares a Godot wrapper for an external C++ class. The wrapper is a minimal,
 * editor-friendly RefCounted that you can extend with methods/properties/signals
 * via _bind_methods().
 *
 * Wrapper: {{ cls.wrapper_name }}
 * Native : {{ cls.qualified_name }}
 */

#include <godot_cpp/classes/ref_counted.hpp>
#include <godot_cpp/core/class_db.hpp>

// Include the native library header that defines {{ cls.qualified_name }}.
// If compile times are a concern, you can switch this to a forward declaration
// and include the native header from the corresponding .cpp instead.
#include <{{ cls.header }}>

namespace godot {

class {{ cls.wrapper_name }} : public RefCounted {
    GDCLASS({{ cls.wrapper_name }}, RefCounted)

  private:
    // NOTE: Adjust ownership/lifetime as needed for your library.
    // This skeleton uses a raw pointer; consider smart pointers or handles.
    {{ cls.absolute_qualified_name }}* impl = nullptr;
    bool owns_impl = true;

  protected:
    static void _bind_methods();

  public:
    {{ cls.wrapper_name }}();
    ~{{ cls.wrapper_name }}();

    // Helper API
    bool is_valid() const;

    // Ownership and impl management
    void reset();
    void set_impl({{ cls.absolute_qualified_name }}* p, bool p_take_ownership = false);
    {{ cls.absolute_qualified_name }}* get_impl() const;
    void set_owns_impl(bool p_own);
    bool get_owns_impl() const;

    // Construct the underlying native object using discovered constructors
{% for m in cls.constructors -%}
    // {{ m.cpp_signature }}
    bool construct{% if m.overload_index is not none and m.overload_index > 0 %}_{{ m.overload_index }}{% endif %}({% for p in m.parameters -%}{{ p.cpp_type.spelling }} {{ (p.name or ('arg' ~ loop.index)) | sanitize }}{% if not loop.last %}, {% endif %}{%- endfor -%});
{% endfor %}

    // Discovered instance methods (wrapping the native API)
{% for m in cls.instance_methods -%}
    // {{ m.cpp_signature }}
    {{ m.return_type.spelling }} {{ m.exposed_name }}({% for p in m.parameters -%}{{ p.cpp_type.spelling }} {{ (p.name or ('arg' ~ loop.index)) | sanitize }}{% if not loop.last %}, {% endif %}{%- endfor -%}){% if m.is_const %} const{% endif %};
{% endfor %}

    // Discovered static methods (wrapping the native API)
{% for m in cls.static_methods -%}
    // static {{ m.cpp_signature }}
    static {{ m.return_type.spelling }} {{ m.exposed_name }}({% for p in m.parameters -%}{{ p.cpp_type.spelling }} {{ (p.name or ('arg' ~ loop.index)) | sanitize }}{% if not loop.last %}, {% endif %}{%- endfor -%});
{% endfor %}
};

} // namespace godot
