/**
 * Variant-mode source generated by the GDExtension binding generator.
 *
 * - Uses mapped (Variant-friendly) signatures only.
 * - Never exposes raw void* in the public API; intptr_t/uint64_t are used instead.
 * - Wrapper-only mode: no ownership API for the native impl pointer.
 * - Emits Godot error macros for developer-friendly diagnostics on impl misuse.
 *
 * Wrapper: {{ cls.wrapper_name }}
 * Native : {{ cls.qualified_name }}
 */

#include "{{ cls.wrapper_name }}.h"
#include <godot_cpp/core/error_macros.hpp>

using namespace godot;

{% macro arg_list(params) -%}
    {%- for p in params -%}
        {{ p.type }} {{ (p.name or ('arg' ~ loop.index)) | sanitize }}{% if not loop.last %}, {% endif %}
    {%- endfor -%}
{%- endmacro %}

{% macro d_method_args(params) -%}
    {%- for p in params -%}
        "{{ (p.name or ('arg' ~ loop.index)) | sanitize }}"{% if not loop.last %}, {% endif %}
    {%- endfor -%}
{%- endmacro %}

{% macro default_ret(rt) -%}
    {%- set T = (rt or "").strip() -%}
    {%- if T == "" or T == "void" -%}/*no_ret*/
    {%- elif T == "bool" -%}false
    {%- elif T.startswith("int") or T.startswith("uint") or T == "intptr_t" or T == "size_t" or T == "ptrdiff_t" -%}0
    {%- elif T == "float" -%}0.0f
    {%- elif T == "double" -%}0.0
    {%- elif T.startswith("godot::Ref<") -%}{{ T }}()
    {%- elif T == "godot::String" -%}godot::String()
    {%- elif "*" in T -%}nullptr
    {%- else -%}{}
    {%- endif -%}
{%- endmacro %}

void {{ cls.wrapper_name }}::_bind_methods() {
    // Constructor wrappers exposed as construct, construct_1, ...
    {% for m in variant.constructors %}
    ClassDB::bind_method(
        D_METHOD("construct{% if m.suffix %}{{ m.suffix }}{% endif %}"{% if m.params and m.params|length > 0 %}, {{ d_method_args(m.params) }}{% endif %}),
        static_cast<bool ({{ cls.wrapper_name }}::*){% if m.params and m.params|length > 0 %}({{ arg_list(m.params) }}){% else %}(){% endif %}>(&{{ cls.wrapper_name }}::construct{% if m.suffix %}{{ m.suffix }}{% endif %})
    );
    {% endfor -%}

    // Instance methods
    {% for m in variant.instance_methods %}
    ClassDB::bind_method(
        D_METHOD("{{ (m.exposed_name or m.name) | sanitize }}"{% if m.params and m.params|length > 0 %}, {{ d_method_args(m.params) }}{% endif %}),
        static_cast<{{ m.return_type }} ({{ cls.wrapper_name }}::*){% if m.params and m.params|length > 0 %}({{ arg_list(m.params) }}){% else %}(){% endif %}{% if m.is_const %} const{% endif %}>(
            &{{ cls.wrapper_name }}::{{ (m.exposed_name or m.name) | sanitize }}
        )
    );
    {% endfor -%}

    // Static methods
    {% for m in variant.static_methods %}
    ClassDB::bind_static_method(
        {{ cls.wrapper_name }}::get_class_static(),
        D_METHOD("{{ (m.exposed_name or m.name) | sanitize }}"{% if m.params and m.params|length > 0 %}, {{ d_method_args(m.params) }}{% endif %}),
        static_cast<{{ m.return_type }} (*){% if m.params and m.params|length > 0 %}({{ arg_list(m.params) }}){% else %}(){% endif %}>(
            &{{ cls.wrapper_name }}::{{ (m.exposed_name or m.name) | sanitize }}
        )
    );
    {% endfor -%}
}

{% if variant and variant.constructors -%}
{% for m in variant.constructors -%}
// mapped ctor: returns bool
bool {{ cls.wrapper_name }}::construct{% if m.suffix %}{{ m.suffix }}{% endif %}({{ arg_list(m.params) }}) {
    if (impl != nullptr) {
        ERR_FAIL_V_MSG(false, "{{ cls.wrapper_name }}::construct{% if m.suffix %}{{ m.suffix }}{% endif %} called but impl is already set. Call reset() first.");
    }
    {% for line in (m.pre_lines or []) -%}
    {{ line }}
    {% endfor -%}
    impl = new {{ cls.absolute_qualified_name }}({{ (m.call_args or []) | join(", ") }});
    if (!impl) {
        ERR_FAIL_V_MSG(false, "Failed to construct native {{ cls.qualified_name }}");
    }
    return true;
}
{% endfor -%}
{% endif %}

{{ cls.wrapper_name }}::{{ cls.wrapper_name }}() {
    // Do not auto-construct; use construct(...) wrappers to initialize impl.
    impl = nullptr;
}

{{ cls.wrapper_name }}::~{{ cls.wrapper_name }}() {
    if (impl != nullptr) {
        // Wrapper-only mode: impl is not owned here; warn once and drop the pointer.
        ERR_PRINT_ONCE(String("~{{ cls.wrapper_name }}(): impl was not null at destruction; native lifetime is managed externally."));
        impl = nullptr;
    }
}

{% if variant and variant.instance_methods -%}
{% for m in variant.instance_methods -%}
// mapped instance: {{ m.name }}
{{ m.return_type }} {{ cls.wrapper_name }}::{{ (m.exposed_name or m.name) | sanitize }}({{ arg_list(m.params) }}){% if m.is_const %} const{% endif %} {
    {% set fallback = m.default_return or default_ret(m.return_type) %}
    {% if fallback != '/*no_ret*/' %}
    ERR_FAIL_NULL_V_MSG(impl, {{ fallback }}, String("{{ cls.wrapper_name }}::{{ (m.exposed_name or m.name) | sanitize }}() called with null impl. Construct or set impl first."));
    {% else %}
    ERR_FAIL_NULL_MSG(impl, String("{{ cls.wrapper_name }}::{{ (m.exposed_name or m.name) | sanitize }}() called with null impl. Construct or set impl first."));
    {% endif %}
    {% for line in (m.pre_lines or []) -%}
    {{ line }}
    {% endfor -%}
    {% set call = (m.call_expr | default(None)) or ('impl->' ~ (m.native_name or m.name) ~ '(' ~ ((m.call_args or []) | join(', ')) ~ ')') %}
    {% if (m.return_type or '').strip() == 'void' %}
    {{ call }};
    return;
    {% else %}
        {% if m.return_transform %}
    return {{ m.return_transform | replace('{expr}', call) }};
        {% else %}
    return {{ call }};
        {% endif %}
    {% endif %}
}
{% endfor -%}
{% endif %}

{% if variant and variant.static_methods -%}
{% for m in variant.static_methods -%}
// mapped static: {{ m.name }}
{{ m.return_type }} {{ cls.wrapper_name }}::{{ (m.exposed_name or m.name) | sanitize }}({{ arg_list(m.params) }}) {
    {% for line in (m.pre_lines or []) -%}
    {{ line }}
    {% endfor -%}
    {% set call = (m.call_expr | default(None)) or (cls.absolute_qualified_name ~ '::' ~ (m.native_name or m.name) ~ '(' ~ ((m.call_args or []) | join(', ')) ~ ')') %}
    {% if (m.return_type or '').strip() == 'void' %}
    {{ call }};
    return;
    {% else %}
        {% if m.return_transform %}
    return {{ m.return_transform | replace('{expr}', call) }};
        {% else %}
    return {{ call }};
        {% endif %}
    {% endif %}
}
{% endfor -%}
{% endif %}
